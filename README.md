# checkers

- Scena CheckersScene zawiera obiekt z komponentem CheckersSceneManager. Tam możemy ustawić podstawowe parametry rozgrywki - rozmiar planszy, liczbę początkowych pionków, liczbę tur, które mają zostać cofnięte po naciśnięciu przycisku cofania oraz zachowania graczy. Pola FirstPlayerCreator i SecondPlayerCreator przyjmują referencję na ScriptableObjecty typu BasePlayerCreator. Tak naprawdę są to wrappery pozwalające przekazywać za pomocą inspektora odpowiednie obiekty implementujące interfejs IPlayer managerowi sceny. Stworzyłem dwa zachowania AI - RandomMovesComputerPlayer (zawsze wykonuje losowy ruch) oraz FirstOptionAlwaysComputerPlayer (zawsze wykonuje pierwszy ruch z listy dostępnych, dzięki temu jest deterministyczny). Jeżeli chcemy stworzyć własne AI (np. o wyższym poziomie trudności), musimy stworzyć nową klasę implementującą interfejs IPlayer. Przeciągając do inspektora managera dwa obiekty HumanPlayerCreator otrzymamy rozgrywkę dla dwóch ludzkich graczy. Jeżeli do jednego pola przeciągniemy gracza komputerowego - otrzymamy rozgrywkę dla jednego gracza walczącemu przeciwko AI. Jeżeli przeciągniemy do obydwóch pól graczy komputerowych - rozegrają oni pomiędzy sobą rozgrywkę natychmiastowo, po uruchomieniu sceny zobaczymy końcowy wynik meczu.
- Skrypty związane z grą umieszczone są w dwóch folderach, posiadających swoje AssemblyDefinition - GameLogic oraz Presentation. Presentation posiada referencję na GameLogic, dzięki czemu jest zachowane odpowiednie oddzielenie kodu odpowiedzialnego za logikę od kodu odpowiedzialnego za prezentację gry graczowi.
-Najważniejszą klasą odpowiadającą za logikę gry jest CheckersGame. Klasa Board reprezentuje planszę gry i jej pola. Najważniejszą klasą odpowiadającą za prezentację gry graczowi jest BoardPresentation.
- Cofanie tur graczy jest zrealizowane za pomocą patternu Command. Każda z trzech podstawowych akcji, które mogą się wydarzyć na planszy (przemieszczenie figury, zbicie figury, awans pionka na damkę) posiada swoją klasę, która implementuje interfejs ICommand. Wykonywane akcje tworzą komendy, które są przechowywane przez obiekt CheckersGame. Po naciścnięciu przycisku cofania na odpowiednich obiektach wywoływana jest metoda Undo.
- Klasy sprawdzające obecnie dostępne dla gracza ruchy implementują interfejs IActionVectorsCalculator. Akcje ruchu i ataku posiadają osobne implementacje tego interfejsu, ponieważ zasady określające kiedy można wykonać te akcje różnią się.
- Testy jednostkowe testujące niektóre elementy programu znajdują się w osobnym folderze Tests z własnym AssemblyDefinition.
